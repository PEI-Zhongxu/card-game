SPEAKER 0
Hello and welcome to this week's videos. We're going to continue our topic on sort algorithms. And we're going to look at slightly more efficient sorting algorithms. These are going to be quicksort and merge sort. So by the end of this week you should be able to understand and explain both the quicksort and merge sort algorithms. And you should be able to understand the Python implementation for both of these sorting algorithms. So unlike the sorting algorithms we saw last week, the quicksort algorithm is actually quite efficient for sorting and the quicksort algorithm. Just as the binary search algorithm falls under the divide and conquer class of algorithms. This is when we break the problem into smaller chunks, and because they are smaller chunks, they're a lot simpler to solve. So the first thing we're going to do is we're going to talk through the theory of the quicksort algorithm. And then we'll look at an example. So the concept behind quick sorting is partitioning or separating a given list or array. And to partition the list, the first thing we need to do is we need to select something called a pivot. And the pivot will be the thing that we compare all the other elements in the list to. And at the end of the partitioning process, all elements that are less than the pivot will be to the left of the pivot. Pivot, whilst all the elements greater than the pivot will lie to the right of the pivot in the array. And there are a number of different ways that we can select the pivot. But in this case, what we're going to do is we are just going to take the first element in our array or our list. So the quicksort algorithm starts by taking the first element in an array or a list as the pivot. What they were going to then do is we're going to partition an unsorted array into two subarrays. The elements that are on the left side of the pivot should be smaller than the pivot, and all the elements on the right side of the pivot should be greater. Also, after the first iteration of the quicksort algorithm, the chosen pivot point is correctly placed in the list. What we then do is repeat these steps until the array is sorted. So in essence, the main idea behind the quicksort algorithm is to move the elements that are on the wrong side of the pivot value. This is done using something called a partition algorithm, and this is performed using two pointers a left and a right pointer. The left pointer initially points to the value at index one, and the index. The right pointer points to the value at the last index. Note that the left pointer doesn't point to the value at index zero. And this. This is because the value of index zero is our pivot point. So we start with the left pointer, and we move from a left to right direction until we reach a position where the item has a greater value than the pivot value. Similarly, we move the right pointer towards the left until we find a value that is less than the pivot value. What we then do is we swap the values indicated by the left and right pointers. We repeat steps 1 to 3 until both pointers cross each other. In other words, when the right pointer index indicates a value less than that of the left pointer index. Finally, we swap the pivot value with the value at the right point index. So let's look at the example of the quicksort algorithm in action. We've got our list starting with 45 and so on and so forth. And we take the first element in that list as our pivot. In this case the example is 45. And if you remember we have two pointers. The left pointer which starts at index zero one which is the value 23 in this case. And the right pointer that starts at the last index. So what we will then do is we'll move the left pointer until there is a value greater than the pivot. And we'll move the left value sorry. The right pointer left until there is a value less than the pivot. So in this case we're going to move the left pointer to the number 87. And we're going to move the right pointer to the number 32. So now we stop there because we have met our two conditions. 87 is greater than 45, and 32 is less than 45. Once that happens, we swap the two values. So 32 is going to go where 87 is and 87 is going to go with 32 is. So once we swap the values we then continue with our rule. So we're going to move the left pointer once again to the right until it encounters a value that is greater than the pivot point. And we're going to move the right pointer left until it encounters a value that is less than the pivot point. So in this case the left pointer is going to move to 12 and then to 72 and stop there. And the right pointer is going to move to 54 and then to the number four, and it's going to stop there. Once that happens, we do the same thing. So we're going to swap the number 72 with the number four. So once we swap the values we'll notice that the right pointer and the left pointer cross crossover. And what happens at that point is the right pointer is then swapped with the pivot. And you'll see that in this case the four is going to be swapped with the number 45. And at the bottom you can see that our list now looks slightly better. In that 45 is definitely sorted. It's in the correct place. We know that because all the values to the left of the point, uh, the number 45 are less than 45. And we know that the values to the right of the number 45 are all greater than 45. So now we have one number that is sorted into the correct place, and we have two sublists the numbers to the left of 45 and the numbers to the right of 45. So what we're going to do is we're going to treat these as two separate lists, and we're going to apply the quicksort algorithm again. So we're going to pick the pivot. So in this case we'll probably have the number four and the number 72 as pivots. And then we'll have left pointers and right pointers. And we'll follow that algorithm through to the very end. So because this idea of partitioning is very important we'll look at the partitioning part of the implementation first. So the first thing we're going to do is we're going to define a function. It's going to take an array. It's going to take the first index. And it's going to take the last index. And what we're going to do is we're going to say the pivot is going to be whatever is in the first index of the list or the array that we're using. And the pivot index, therefore is the first index or zero in this case. So note that the partition function receives as its parameters both the indices of the first and last elements of the array that we need to partition. So the next thing we're going to do is we're going to define the right pointer and the left pointer. So the right pointer is going to point to the last index of the list we're trying to partition. And the left pointer is going to point to the first index and one position over. So if you remember the pivot is index zero. So the left pointer in a full list is going to point to the first index zero plus one. So it's going to point to index one. So the next thing we're going to do is define the movement of the left pointer and the right pointer. So what we're going to do with the left pointer is going to move along the list from left to right until we reach a point where the item we're looking at is greater than the pivot value. In the same case, we're going to move the right pointer to the left until we find a value that is less than the pivot. And you should see that this is what the Python code in front of you is doing. Once we get to a point where the left value is pointing to a value that is greater than the pivot, and the right pointer is pointing to a value that is less than a pivot. We then use the Python code to swap those two values. The last part of the code that we need to implement is when the left pointer is at a point that is greater than the right pointer. We're going to swap the value of the right pointer with the pivot value. So in this case we're going to swap 43 and four. And you'll see that 43 will then be in the right place in the list. So now we've got to a point where all the elements to the right of the element 43 are greater, and all the items to the left are smaller. That part is complete. And now we'll use the split the split point 43 with the index three. And when. Then we'll recursively sort through the two subarrays. So 43 and 20 and 89 and 77. So in terms of complexity the partition algorithm is O n log n which is basically the partition parts of the algorithm takes own time. And then the dividing and conquering part of it is o log n. If we add those together or sorry, multiply those together, we get o n log n. The quicksort algorithm gives a worst case runtime complexity of o n squared. The worst case complexity for this quicksort algorithm would be when it selects the worst pivot point every single time, and one of the partitions then always has a single element, and this might occur if the list is already sorted. So the worst case complexity would occur if the partition picks the smallest element as the pivot point. When worst case complexity occurs, the quicksort algorithm can be improved using the randomised quicksort, so you are randomising the elements in the list before you then sort it. So the quicksort algorithm is very efficient when sorting large amounts of data compared to other algorithms that we've looked at, such as bubble insertion or selection sort.
