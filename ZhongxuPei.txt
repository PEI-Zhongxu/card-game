# ---------------------- è‡ªå®šä¹‰æ•°æ®ç»“æ„ ----------------------
class PriorityDeck:
    """åŸºäºä¼˜å…ˆé˜Ÿåˆ—çš„ç‰Œå †ç®¡ç†ç³»ç»Ÿï¼ˆæ›¿æ¢åŸç”Ÿdequeï¼‰"""
    def __init__(self):
        self.heap = []
        self.counter = 0  # è§£å†³ç›¸åŒä¼˜å…ˆçº§å…ƒç´ çš„æ¯”è¾ƒé—®é¢˜

    def push(self, card: 'Card', priority: int = 0) -> None:
        """æ·»åŠ å¡ç‰Œåˆ°ä¼˜å…ˆé˜Ÿåˆ—"""
        heappush(self.heap, (priority, self.counter, card))
        self.counter += 1

    def pop(self) -> 'Card':
        """ä»é˜Ÿåˆ—ä¸­å–å‡ºæœ€é«˜ä¼˜å…ˆçº§çš„å¡ç‰Œ"""
        return heappop(self.heap)[-1] if self.heap else None

    def __len__(self) -> int:
        return len(self.heap)


class DecisionGraph:
    """åŸºäºå›¾ç»“æ„çš„AIå†³ç­–ä¼˜åŒ–ç³»ç»Ÿ"""
    def __init__(self, game_state: 'CrazyEightsGame'):
        self.graph = defaultdict(list)
        self.build_graph(game_state)

    def build_graph(self, state: 'CrazyEightsGame') -> None:
        """æ„å»ºæ¸¸æˆçŠ¶æ€å†³ç­–å›¾ï¼ˆç®€åŒ–ç¤ºä¾‹ï¼‰"""
        for card in state.c_hand:
            simulated_state = self.simulate_play(state, card)
            self.graph[state].append((simulated_state, card))

    def find_optimal_play(self) -> Optional['Card']:
        """ä½¿ç”¨BFSå¯»æ‰¾æœ€ä¼˜å‡ºç‰Œç­–ç•¥ï¼ˆç¤ºä¾‹é€»è¾‘ï¼‰"""
        queue = deque([(self.graph[state], 0) for state in self.graph])
        best_card = None
        max_score = -float('inf')
        
        while queue:
            current_state, depth = queue.popleft()
            for next_state, card in current_state:
                score = self.evaluate_state(next_state)
                if score > max_score:
                    max_score = score
                    best_card = card
                if depth < 2:  # é™åˆ¶æœç´¢æ·±åº¦
                    queue.append((self.graph[next_state], depth + 1))
        return best_card

    @staticmethod
    def evaluate_state(state: 'CrazyEightsGame') -> int:
        """è¯„ä¼°æ¸¸æˆçŠ¶æ€å¾—åˆ†"""
        return sum(c.value for c in state.c_hand) - sum(p.value for p in state.p_hand)

    @staticmethod
    def simulate_play(state: 'CrazyEightsGame', card: 'Card') -> 'CrazyEightsGame':
        """æ¨¡æ‹Ÿå‡ºç‰Œåçš„æ–°çŠ¶æ€"""
        new_state = CrazyEightsGame()
        new_state.__dict__ = state.__dict__.copy()
        new_state.c_hand.remove(card)
        new_state.up_card = card
        new_state.active_suit = card.suit
        return new_state


# ---------------------- æ ¸å¿ƒæ¸¸æˆé€»è¾‘ ----------------------
class Card:
    """å•å¼ æ‰‘å…‹ç‰Œçš„ç±»ï¼ŒåŒ…å«èŠ±è‰²ã€ç‚¹æ•°å’Œç‰¹æ®Šè§„åˆ™"""
    def __init__(self, suit_id: int, rank_id: int) -> None:
        self.suit_id = suit_id
        self.rank_id = rank_id

        # è‡ªåŠ¨è®¡ç®—ç‰Œé¢å±æ€§
        self.rank, self.value = self._determine_rank_value()
        self.suit = self._determine_suit()
        
        # ç”Ÿæˆæ˜¾ç¤ºåç§°
        self.short_name = f"{self.rank[0]}{self.suit[0]}" if self.rank != '10' else f"{self.rank}{self.suit[0]}"
        self.long_name = f"{self.rank} of {self.suit}"

    def _determine_rank_value(self) -> Tuple[str, int]:
        """ç¡®å®šç‰Œé¢ç‚¹æ•°å’Œå¯¹åº”çš„æ¸¸æˆåˆ†å€¼"""
        if self.rank_id == 1:
            return "Ace", 1
        elif 2 <= self.rank_id <= 10:
            return str(self.rank_id), self.rank_id
        elif self.rank_id == 8:
            return "8", 50  # ç‰¹æ®Šè§„åˆ™ï¼š8çš„åˆ†æ•°å€¼ä¸º50
        return {11: ("Jack", 10), 12: ("Queen", 10), 13: ("King", 10)}.get(self.rank_id, ("RankError", -1))

    def _determine_suit(self) -> str:
        """å°†æ•°å­—IDè½¬æ¢ä¸ºèŠ±è‰²åç§°"""
        return {1: "Diamonds", 2: "Hearts", 3: "Spades", 4: "Clubs"}.get(self.suit_id, "SuitError")

    def __repr__(self) -> str:
        return self.short_name


class CrazyEightsGame:
    """ä¸»æ¸¸æˆç±»ï¼Œç®¡ç†æ¸¸æˆçŠ¶æ€å’Œæµç¨‹"""
    def __init__(self) -> None:
        self.deck: PriorityDeck = PriorityDeck()
        self.p_hand: List[Card] = []
        self.c_hand: List[Card] = []
        self.up_card: Optional[Card] = None
        self.active_suit: str = ""
        self.blocked: int = 0
        self._init_logging()

    def _init_logging(self) -> None:
        """åˆå§‹åŒ–æ—¥å¿—ç³»ç»Ÿ"""
        logging.basicConfig(
            filename='crazy8.log',
            level=logging.DEBUG,
            format='%(asctime)s - %(levelname)s - %(message)s'
        )

    # ---------------------- ç‰Œå †ç®¡ç† ----------------------
    def _custom_shuffle(self, deck: List[Card]) -> List[Card]:
        """Fisher-Yatesæ´—ç‰Œç®—æ³•ï¼ˆæ›¿æ¢random.shuffleï¼‰"""
        for i in range(len(deck)-1, 0, -1):
            j = random.randint(0, i)
            deck[i], deck[j] = deck[j], deck[i]
        return deck

    def init_deck(self) -> None:
        """åˆå§‹åŒ–å¹¶æ´—ç‰Œ"""
        raw_deck = []
        for suit_id in range(1, 5):
            for rank_id in range(1, 14):
                raw_deck.append(Card(suit_id, rank_id))
        self._custom_shuffle(raw_deck)
        
        self.deck = PriorityDeck()
        for card in raw_deck:
            self.deck.push(card, random.randint(1, 100))  # ä½¿ç”¨ä¼˜å…ˆé˜Ÿåˆ—

    # ---------------------- æ¸¸æˆæµç¨‹ ----------------------
    def deal_hands(self) -> None:
        """å‘ç‰Œé€»è¾‘"""
        self.p_hand = [self.deck.pop() for _ in range(5)]
        self.c_hand = [self.deck.pop() for _ in range(5)]
        self.up_card = self.deck.pop()
        self.active_suit = self.up_card.suit
        logging.info(f"New round started. Up card: {self.up_card}")

    def _validate_move(self, card: Card) -> bool:
        """éªŒè¯å‡ºç‰Œåˆæ³•æ€§"""
        return any([
            card.rank == '8',
            card.suit == self.active_suit,
            card.rank == self.up_card.rank
        ])

    # ---------------------- ç©å®¶å›åˆ ----------------------
    def player_turn(self) -> None:
        """å¤„ç†ç©å®¶å›åˆ"""
        print("\nYour hand:", ", ".join(card.short_name for card in self.p_hand))
        print("Up card:", self.up_card.short_name, f"(Active suit: {self.active_suit})")

        while True:
            try:
                move = input("Play a card (e.g. '8H') or 'draw': ").strip().upper()
                if move == 'DRAW':
                    self._handle_draw(self.p_hand)
                    return

                selected = next((c for c in self.p_hand if c.short_name == move), None)
                if not selected:
                    raise ValueError("Card not in hand")
                if not self._validate_move(selected):
                    raise ValueError("Invalid move")

                self._apply_play(selected, self.p_hand)
                if selected.rank == '8':
                    self._change_suit()
                return

            except (ValueError, StopIteration) as e:
                logging.warning(f"Invalid player input: {str(e)}")
                print(f"Error: {str(e)}. Please try again.")

    # ---------------------- ç”µè„‘AI ----------------------
    def computer_turn(self) -> None:
        """ä½¿ç”¨å†³ç­–å›¾ä¼˜åŒ–ç”µè„‘å‡ºç‰Œ"""
        logging.info("Computer's turn started")
        graph = DecisionGraph(self)
        best_play = graph.find_optimal_play()

        if best_play:
            self._apply_play(best_play, self.c_hand)
            print(f"Computer played {best_play.short_name}")
        else:
            self._handle_draw(self.c_hand)
            print("Computer drew a card")

    # ---------------------- è¾…åŠ©æ–¹æ³• ----------------------
    def _handle_draw(self, hand: List[Card]) -> None:
        """å¤„ç†æŠ½ç‰Œé€»è¾‘"""
        if card := self.deck.pop():
            hand.append(card)
            logging.info(f"Player drew: {card}")
        else:
            self.blocked += 1
            logging.warning("Deck is empty")

    def _apply_play(self, card: Card, hand: List[Card]) -> None:
        """åº”ç”¨å‡ºç‰Œæ“ä½œ"""
        hand.remove(card)
        self.up_card = card
        self.active_suit = card.suit
        logging.debug(f"Played: {card}")

    def _change_suit(self) -> None:
        """ç©å®¶å‡º8åæ›´æ¢èŠ±è‰²"""
        suit_map = {'D': 'Diamonds', 'H': 'Hearts', 'S': 'Spades', 'C': 'Clubs'}
        while True:
            choice = input("Choose new suit [D/H/S/C]: ").upper()
            if choice in suit_map:
                self.active_suit = suit_map[choice]
                logging.info(f"Suit changed to {self.active_suit}")
                print(f"New active suit: {self.active_suit}")
                return
            print("Invalid choice. Please try again.")

    # ---------------------- æ¸¸æˆå¾ªç¯ ----------------------
    def play_game(self) -> None:
        """ä¸»æ¸¸æˆå¾ªç¯"""
        rounds = random.randint(3, 5)
        print(f"Starting {rounds}-round game!")
        total_scores = {'Player': 0, 'Computer': 0}

        for round_num in range(1, rounds+1):
            print(f"\n=== Round {round_num} ===")
            self.init_deck()
            self.deal_hands()
            self.blocked = 0

            while self.p_hand and self.c_hand and self.blocked < 2:
                self.player_turn()
                if not self.p_hand: break
                self.computer_turn()

            # è®¡ç®—å¾—åˆ†
            p_score = sum(c.value for c in self.c_hand)
            c_score = sum(c.value for c in self.p_hand)
            total_scores['Player'] += p_score
            total_scores['Computer'] += c_score

        # æ˜¾ç¤ºæœ€ç»ˆç»“æœ
        print("\n=== Final Scores ===")
        print(f"Player: {total_scores['Player']}")
        print(f"Computer: {total_scores['Computer']}")
        if total_scores['Player'] > total_scores['Computer']:
            print("ğŸ‰ You win the game!")
        else:
            print("ğŸ¤– Computer wins the game!")


if __name__ == "__main__":
    try:
        CrazyEightsGame().play_game()
    except Exception as e:
        logging.critical(f"Game crashed: {str(e)}", exc_info=True)
        print("A critical error occurred. Check crazy8.log for details.")
